{
    "milestones": [
        {
            "id": 1,
            "year":  1991,
            "name":  "HTML",
            "description":  "Самые первые сайты, и как верстались в то время они",
            "code_language":  "html",
            "fragments": [
                {
                    "id": 0,
                    "hardness": -1,
                    "name": "",
                    "description": "",
                    "default_text": "<header>",
                    "only_for_system": true
                },
                {
                    "id": 10,
                    "hardness": 0.0,
                    "name": "Логотип сайта",
                    "description": "Необходимо создать элемент, показывающий логотип сайта. Он должен растигиваться на 100% предоставленной ему ширины и высоты.",
                    "default_text": "<div>\n  <img>\n</div>"
                },
                {
                    "id": 20,
                    "hardness": 0.8,
                    "name": "Navbar (навигационная панель)",
                    "description": "Необходимо создать элемент, показывающий навигационную панель сайта. Он должен растигиваться на 100% предоставленной ему ширины, в нём должны быть выровненные в ряд ссылки на разделы сайта. Можно добавить информацию о профиле пользователя справа.",
                    "default_text": "<nav>\n  <a></a>\n  <a></a>\n  <a></a>\n  <a></a>\n</nav>"
                },
                {
                    "id": 30,
                    "hardness": -1,
                    "name": "",
                    "description": "",
                    "default_text": "</header>\n<main style=\"margin: 20px 60px; padding: 30px;\">",
                    "only_for_system": true
                },
                {
                    "id": 40,
                    "hardness": 0.9,
                    "name": "Галерея фото",
                    "description": "Необходимо создать галерею с тремя фотографиями, растягиващимися по ширине страницы. Каждое из них должно быть всегда квадратным независимо от размера исходной картинки.",
                    "default_text": "<section>\n  <h1></h1>\n  <div>\n    <img>\n    <img>\n    <img>\n  </div>\n</section>"
                },
                {
                    "id": 50,
                    "hardness": 0,
                    "name": "Разделительная черта",
                    "description": "Необходимо добавить горизонтальную разделительную черту, разделяющую гелерею и основной текст страницы.",
                    "default_text": ""
                },
                {
                    "id": 60,
                    "hardness": 0.4,
                    "name": "Параграф с заголовком",
                    "description": "Необходимо добавить заголовок блока и простой текстовый блок с каким-то большим текстом.",
                    "default_text": "<section>\n  <h2></h2>\n  <p></p>\n</section>"
                },
                {
                    "id": 70,
                    "hardness": 0.5,
                    "name": "Параграф со списком",
                    "description": "Необходимо создать текстовый блок со включенным в него маркированым списком.",
                    "default_text": "<section>\n  <p></p>\n</section>"
                },
                {
                    "id": 80,
                    "hardness": 0.5,
                    "name": "Разворачивающийся список",
                    "description": "Необходимо создать блок с заголовком и текстом, разворачивающимся при клике на заголовок. По умолчанию текст должен быть развернут.",
                    "default_text": "<section>\n  <details></details>\n</section>"
                },
                {
                    "id": 90,
                    "hardness": 1,
                    "name": "Форма с данными",
                    "description": "Необходимо создать форму с заголовком, в которую пользователь может вводить данные, чтобы мы ему перезвонили. Нам нужно узнать: Имя, Телефон, Любой текст, который он захочет оставить.",
                    "default_text": "<section>\n  <form>\n    <header></header>\n    <label for=\"some-input-id\"></label>\n    <input id=\"some-input-id\">\n  </form>\n</section>"
                },
                {
                    "id": 100,
                    "hardness": 1,
                    "name": "Форма калькулятора",
                    "description": "Необходимо создать форму для калькулятора подсчета общей стоимости товаров. Необходимо два поля ввода чисел: для стоимости товара и для количества товара, а так же элемент для показа итогового результата.",
                    "default_text": "<section>\n  <form>\n    <header></header>\n    <label for=\"some-input-id\"></label>\n    <input id=\"some-input-id\">\n  </form>\n</section>"
                },
                {
                    "id": 110,
                    "hardness": -1,
                    "name": "",
                    "description": "",
                    "default_text": "</main>",
                    "only_for_system": true
                },
                {
                    "id": 120,
                    "hardness": 0.8,
                    "name": "Footer (подвал) сайта",
                    "description": "Необходимо создать футер(подвал) сайта со списком контактов, а так же ссылками на соцсети, телефонным номером и email'ом",
                    "default_text": "<footer>\n  <a>\n    <img><span>VK</span>\n  </a>\n</footer>"
                }
            ]
        },


        {
            "id": 2,
            "year":  1996,
            "name":  "CSS",
            "description":  "Появление CSS и простая стилизация элементов на странице",
            "code_language":  "css",
            "fragments": [
                {
                    "id": 10,
                    "hardness": 0.0,
                    "name": "Логотип сайта",
                    "description": "Стилизуйте логотип сайта. Ваша часть вёрстки:\n\n<header class=\"header\">\n  <div class=\"header__logo\">\n    <div class=\"header__logo__top\">Mobile</div>\n    <div class=\"header__logo__bottom\">\n      <span>store</span>\n      <img src=\"../../res/res-site-2/logo.svg\" alt=\"logo\">\n    </div>\n  </div>\n</header>",
                    "default_text": ".header {\n  padding: ;\n  background: ;\n}\n.header__logo {\n  font-size: ;\n}\n.header__logo img {\n  height: 50px;\n  margin: ;\n}\n.header__logo__bottom {\n  display: flex;\n  align-items: ;\n  justify-content: ;\n}"
                },
                {
                    "id": 20,
                    "hardness": 0.6,
                    "name": "Navbar (навигационная панель)",
                    "description": "Стилизуйте navbar сайта. Ваша часть вёрстки:\n\n<header class=\"header\">\n  <nav class=\"navbar\">\n    <a class=\"navbar__link\" href=\"#products\">Продукция</a>\n    <a class=\"navbar__link\" href=\"#questions\">Вопросы</a>\n    <a class=\"navbar__link\" href=\"#about\">О нас</a>\n    <a class=\"navbar__link\" href=\"#contacts\">Контакты</a>\n  </nav>\n</header>",
                    "default_text": ".navbar {\n  display: flex;\n  justify-content: ;\n  align-items: ;\n}\n.navbar__link {\n  transition: ___ 0.2s ease;\n}\n.navbar__link:hover {\n}"
                },
                {
                    "id": 30,
                    "hardness": 0,
                    "name": "Основная часть и разделительная линия",
                    "description": "Стилизуйте основную часть сайта и разделительную горизонтальную линию. Стили для <section> не нужны. Ваша часть вёрстки:\n\n<main class=\"main\">\n  <section class=\"section\"></section>\n  <hr>\n  <section class=\"section\"></section>\n  ...\n</main>",
                    "default_text": ".main {\n  background: ;\n  color: ;\n}\n.main hr {\n  margin: ;\n  border: ;\n}"
                },
                {
                    "id": 40,
                    "hardness": 0.6,
                    "name": "Блок основной части",
                    "description": "Стилизуйте блок с заголовком и текстом блока. Сделайте так, чтобы блоки через один (каждый второй) были разной стилизации. Ваша часть вёрстки:\n\n<section class=\"section\">\n  <header class=\"section__header\">**Текст заголовка**</header>\n  <p class=\"section__paragraph\">**Полный текст блока**</p>\n</section>\n<section class=\"section\">\n  <header class=\"section__header\">**Текст заголовка**</header>\n  <p class=\"section__paragraph\">**Полный текст блока**</p>\n</section>\n<section class=\"section\">\n  <header class=\"section__header\">**Текст заголовка**</header>\n  <p class=\"section__paragraph\">**Полный текст блока**</p>\n</section>",
                    "default_text": ".section {\n  padding: ;\n}\n.section:___ {\n}\n.section__header {\n  text-align: ;\n  font-size: ;\n  padding: ;\n}"
                },
                {
                    "id": 50,
                    "hardness": 0.6,
                    "name": "Галерея изображений",
                    "description": "Стилизуйте галерею изображений. Все картинки должны быть квадратными, умещаться ровно по 3 в строку. Вся галерея должна быть растянута на всю ширину. Ваша часть вёрстки:\n\n<div class=\"gallery\">\n  <img class=\"gallery__image\" src=\"...\" alt=\"phone\">\n  <img class=\"gallery__image\" src=\"...\" alt=\"phone\">\n  <img class=\"gallery__image\" src=\"...\" alt=\"phone\">\n</div>",
                    "default_text": ".gallery {\n  display: flex;\n  justify-content: ;\n}\n.gallery__image {\n  width: 50%;\n  aspect-ratio: ;\n  object-fit: ;\n}"
                },
                {
                    "id": 60,
                    "hardness": 0.2,
                    "name": "Маркированый список",
                    "description": "Стилизуйте маркированый список, в каждом элементе которого есть заголовок и описание. Ваша часть вёрстки:\n\n<ul class=\"section__list\">\n  <li class=\"list__item\">\n    <header class=\"item__header\">**Заголовок**</header>\n    <span class=\"item__description\">**Текст**</span>\n  </li>\n  <li class=\"list__item\">\n    <header class=\"item__header\">**Заголовок**</header>\n    <span class=\"item__description\">**Текст**</span>\n  </li>\n  <li class=\"list__item\">\n    <header class=\"item__header\">**Заголовок**</header>\n    <span class=\"item__description\">**Текст**</span>\n  </li>\n</ul>",
                    "default_text": ".section__list {\n  padding: ;\n}\n.list__item {\n  padding: ;\n}\n.item__header {\n  font-size: ;\n}\n.item__description {\n  font-size: ;\n}"
                },
                {
                    "id": 70,
                    "hardness": 0.6,
                    "name": "Раскрывающийся список",
                    "description": "Стилизуйте раскрывающийся список. Элементы внутри него должен быть через один(каждый второй) стилизованы по-разному. Ваша часть вёрстки:\n\n<details class=\"details\" open>\n  <summary class=\"details__summary\">Наши клиенты</summary>\n  <div class=\"details__text\">\n    <div><img src=\"...\" alt=\"logo\">Газпром</div>\n    <div><img src=\"...\" alt=\"logo\">Роснефть</div>\n    <div><img src=\"...\" alt=\"logo\">Сбер</div>\n    <div><img src=\"...\" alt=\"logo\">Т-Банк</div>\n    ...\n  </div>\n</details>",
                    "default_text": ".details {\n}\n.details__summary {\n  font-size: ;\n  cursor: ;\n}\n.details__text {\n  padding: ;\n}\n.details__text > * {\n  display: flex;\n  align-items: ;\n  gap: ;\n  padding: ;\n}\n.details__text > *:nth-child(2n) {\n}\n.details__text img {\n  width: 25px;\n  height: 25px;\n}"
                },
                {
                    "id": 80,
                    "hardness": 0.5,
                    "name": "Форма ввода данных",
                    "description": "Стилизуйте форму ввода данных, заголовок в ней, подпись под ним, а так же кнопку отправки формы. Контейнеры с полями ввода стилизовать не нужно. Ваша часть вёрстки:\n\n<form class=\"form-contacts\" action=\"javascript:alert('Форма отправлена')\">\n  <header class=\"form-contacts__header\">**Заголовок**</header>\n  <div class=\"form-contacts__description\">**Описание**</div>\n\n  <div class=\"**Контейнер полей ввода**\">...</div>\n  <div class=\"**Контейнер полей ввода**\">...</div>\n  <div class=\"**Контейнер полей ввода**\">...</div>\n  \n  <input class=\"form-contacts__input-submit\" type=\"submit\" value=\"Отправить\">\n</form>",
                    "default_text": ".form-contacts {\n  background: ;\n  color: ;\n  padding: ;\n  margin: ;\n}\n.form-contacts__header {\n  text-align: ;\n  font-size: ;\n}\n.form-contacts__description {\n  text-align: ;\n  margin-bottom: ;\n}\n.form-contacts__input-submit {\n  display: block;\n  margin: ;\n  padding: ;\n  font-size: ;\n  cursor: ;\n  background: ;\n  border: ;\n  transition: ___ 0.2s ease;\n}\n.form-contacts__input-submit:hover {\n}"
                },
                {
                    "id": 90,
                    "hardness": 1,
                    "name": "Поля ввода данных",
                    "description": "Стилизуйте поля ввода данных внутри формы. Ваша часть вёрстки:\n\n<form class=\"...\" action=\"javascript:alert('Форма отправлена')\">\n  <div class=\"form-contacts__input-container\">\n    <label class=\"input-container__label\">Ваше имя</label>\n    <input class=\"input-container__input\" type=\"text\" name=\"name\" placeholder=\"Иван Иванов\" required>\n  </div>\n  <div class=\"form-contacts__input-container\">\n    <label class=\"input-container__label\">Номер телефона:</label>\n    <input class=\"input-container__input\" type=\"tel\" name=\"tel\" placeholder=\"8-XXX-XXX-XX-XX\" required>\n  </div>\n  <div class=\"form-contacts__input-container\">\n    <div class=\"form-contacts__input-radio-group\">\n      <label class=\"input-container__label\">Продажа</label>\n      <input class=\"input-container__input\" type=\"radio\" name=\"question-theme\" required>\n    </div>\n    ... (Всего 3 таких radio-пункта) ...\n  </div>\n  <div class=\"form-contacts__input-container\">\n    <label class=\"input-container__label\">Любые пояснения</label>\n    <textarea class=\"input-container__input\" name=\"name\"></textarea>\n  </div>\n</form>",
                    "default_text": ".form-contacts__input-container {\n  padding: ;\n  display: flex;\n  justify-content: ;\n  gap: ;\n}\n.input-container__label {\n}\n.input-container__input {\n}\ntextarea.input-container__input {\n  resize: vertical;\n}\n.form-contacts__input-radio-group .input-container__label {\n  margin-right: ;\n}"
                },
                {
                    "id": 100,
                    "hardness": 1,
                    "name": "Форма калькулятора",
                    "description": "Стилизуйте форму калькулятора подсчета общей стоимости. Ваша часть вёрстки:\n\n<form class=\"form-calculator\">\n  <header class=\"form-calculator__header\">**Заголовок**</header>\n\n  <div class=\"form-calculator__input-container\">\n    <label class=\"input-calculator__label\">Стоимость телефона</label>\n    <input class=\"input-calculator__input\">\n  </div>\n  <div class=\"form-calculator__input-container\">\n    <label class=\"input-calculator__label\">Количество телефонов</label>\n    <input class=\"input-calculator__input\">\n  </div>\n\n  <div class=\"form-calculator__result\">Общая стоимость: <span id=\"form-calculator__result\"></span></div>\n</form>",
                    "default_text": ".form-calculator {\n  padding: ;\n  color: ;\n}\n.form-calculator__header {\n  text-align: ;\n  font-size: ;\n  margin-bottom: ;\n}\n.form-calculator__input-container {\n  padding: ;\n  display: flex;\n  justify-content: ;\n  align-items: ;\n  gap: ;\n}\n.input-calculator__label {\n}\n.input-calculator__input {\n  padding: ;\n  background: ;\n  border: ;\n}"
                },
                {
                    "id": 110,
                    "hardness": 1,
                    "name": "Footer (подвал)",
                    "description": "Стилизуйте footer (подвал) сайта. Все контакты кроме телефона могут располагаться вертикально у левой стороны, а телефон - у правой. Ваша часть вёрстки:\n\n<footer class=\"footer\">\n  <div class=\"footer__left-column\">\n    <h2 class=\"footer__header\">Mobile store</h2>\n    <small class=\"footer__description\">Ваш надежный проводник в мир мобильных телефонов</small>\n    \n    <a class=\"footer__link\" href=\"https://vk.com/bmstu1830\" target=\"_blank\">\n      <img src=\"...\" alt=\"vk\"><span>VK</span>\n    </a>\n    <a class=\"footer__link\" href=\"https://t.me/bmstu1830\" target=\"_blank\">\n      <img src=\"...\" alt=\"tg\"><span>TG</span>\n    </a>\n    <a class=\"footer__link footer__link_email\" href=\"mailto:contacts@mobile.phones\" target=\"_blank\">\n      <img src=\"...\" alt=\"email\"><span>contacts@mobile.phones</span>\n    </a>\n  </div>\n\n  <div class=\"footer__right-column\">\n    <a class=\"footer__link footer__link_telephone\" href=\"tel:+79999999999\" target=\"_blank\">\n      <span>+7 999 999 99 99</span>\n    </a>\n  </div>\n</footer>",
                    "default_text": ".footer {\n  padding: ;\n  background: ;\n  display: flex;\n  justify-content: ;\n}\n.footer__header {\n}\n.footer__description {\n}\n.footer__link {\n  display: flex;\n  align-items: ;\n  gap: ;\n  transition: ___ 0.2s ease;\n}\n.footer__link:hover {\n}\n.footer__link.footer__link_email {\n}\n.footer__link.footer__link_telephone {\n}\n.footer__link img {\n  width: 30px;\n  height: 30px;\n}"
                }
            ]
        },

        {
            "id": 3,
            "year":  1997,
            "name":  "JS",
            "description":  "Появление JS и взаимодействие с HTML DOM из кода JS",
            "code_language":  "javascript",
            "fragments": [
                {
                    "id": 10,
                    "hardness": 0.4,
                    "name": "Отправка формы",
                    "description": "Необходимо перехватывать событие 'submit' отправки формы, предотвращать его поведение по умолчанию, после чего отправлять POST-запрос на сайт \"https://example.com/send-form\", с JSON-данными в теле в следующем формате:\n\n{\n  \"name\": string,\n  \"phone\": string,\n  \"question_theme\": \"sell\" | \"fix\" | \"info\"\n  \"texts\": string\n}\n\nid HTML-элементов:\n-формы: \"form-contacts\"\n- инпут ввода имени: \"form-contacts__input-name\"\n-инпут ввода телефона: \"form-contacts__input-phone\"\n-инпут ввода текста пояснений: \"form-contacts__input-text\"\n Инпуты с type=\"radio\" для выбора типа обращения имеют атрибут name=\"question-theme\".",
                    "default_text": "// Получаем HTML-элементы\nconst formElement = document.getElementById(___);\nconst inputNameElement = document.getElementById(___);\nconst inputPhoneElement = document.getElementById(___);\nconst inputTextsElement = document.getElementById(___);\nformElement.addEventListener(___, async (event) => {\n  // Ожидаем подтверждения пользователем в модальном окне\n  if (!await confirm('Подтвердите отправку данных')) {\n    return;\n  }\n  // Отправляем запрос\n  await fetch(___, {\n    method: ___,\n    headers: {\n      ___\n    },\n    body: JSON.stringify({\n      ___\n    }),\n  });\n  // TODO: Необходимо добавить проверку на то, что запрос принят сервером\n  // Говорим спасибо, что человек отправил форму\n  formElement.innerHTML = ___;\n});"
                },
                {
                    "id": 20,
                    "hardness": 1,
                    "name": "Показ модального окна",
                    "description": "Требуется заменить браузерную функцию confirm новой реализацией. Она должна принимать один аргумент - сообщение в окне, показывать модальное окно с переданным текстом и двумя кнопками \"Да\" и \"Нет\", и возвращать Promise, который резолвится со значением true или false, когда пользователь нажимает на соответствующую кнопку",
                    "default_text": "___ = (message = '') => {\n  // TODO: Создать Promise и сохранить его функцию resolve в переменную resolvePromiseFunction \n  let resolvePromiseFunction;\n  const promise = new Promise(___);\n\n  // Создание элемента фона\n  const modalElementRoot = document.createElement('div');\n  modalElementRoot.style.position = 'fixed';\n  modalElementRoot.style.inset = '0';\n  // TODO: добавить полу-прозрачный фон\n\n  // Создание элемента формы\n  const modalElementForm = ___;\n  Object.assign(modalElementForm.style, {\n    position: 'fixed',\n    top: '50%',\n    left: '50%',\n    // TODO: выровнять форму по центру. Сейчас в центре экрана находится её левый верхний угол\n    // TODO: определить ширину формы (подстраивающуюся под размер экрана)\n    // TODO: сделать красиво. Отступы, фон, цвет текста, скругления, и т.д.\n  });\n  modalElementRoot.appendChild(___);\n\n  // Создание элемента текста внутри формы\n  const modalElementFormText = document.createElement('div');\n  modalElementFormText.innerText = message;\n  // TODO: Добавить стили для текста\n  ___.appendChild(___);\n\n  // Создание элементов кнопок внутри формы\n  const modalElementFormButtons = [\n    document.createElement(___),\n    document.createElement(___),\n  ];\n  modalElementFormButtons.forEach(button => {\n    button.style.padding = '10px';\n    // TODO: Добавить красивые стили для кнопок. Не забыть выровнять каждую из них по половине ширины формы\n    // TODO: Сделать так, чтобы при наведении курсора на кнопку, он становился указателем на кликабельную зону\n    ___.appendChild(button);\n  });\n  modalElementFormButtons[0].innerText = ___;\n  modalElementFormButtons[0].addEventListener('click', () => {\n    // TODO: Зарезолвить промис с нужным значением и удалить элемент формы с экрана\n  });\n  modalElementFormButtons[1].innerText = ___;\n  modalElementFormButtons[1].addEventListener('click', () => {\n    // TODO: Зарезолвить промис с нужным значением и удалить элемент формы с экрана\n  });\n\n  // Добавляем созданный корневой элемент в DOM\n  document.body.appendChild(___);\n\n  return promise;\n};"
                },
                {
                    "id": 30,
                    "hardness": 0.5,
                    "name": "Анимация с зависимостью от положения курсора",
                    "description": "Необходимо добавить для каждой картинки в галерее (для каждого элемента внутри элемента с id=\"gallery\") эффект поворота в сторону курсора мыши.\n\nПростой вариант: в стилях CSS для этих элементов уже прописаны зависимости от css-переменных положения курсора --x, --y и размера страницы --total-width, --total-height. Их нужно устанавливать через JS при передвижениях мыши\n\nСложный вариант: при передвижении мыши в зависимости от положения элемента и положения курсора необходимо устанавливать css-свойство transform, прописывать ему смещения и повороты",
                    "default_text": "const galleryElements = document.querySelectorAll(___);\ndocument.addEventListener(___, (event) => {\n  ___.forEach(element => {\n    // Следующие 3 строки кода необходимы для работы другой части кода. Не убирайте\n    if (element.hasAttribute('data-is-fullscreen')) {\n      return;\n    }\n\n    // Простой (и правильный) вариант\n    element.setAttribute('style', `\n      ___: ${___};\n      ___: ${___};\n      ___: ${___};\n      ___: ${___};\n    `);\n\n    // Сложный вариант\n    // const {top: elementTop, left: elementLeft} = element.getBoundingClientRect();\n    // const cursorX = ___;\n    // const cursorY = ___;\n    // const ROTATION_DEG = 60;\n    // const TRANSLATION_PX = 60;\n    // element.style.___ = `\n    //   rotateX(${___ * ROTATION_DEG}deg)\n    //   rotateY(${___ * ROTATION_DEG}deg)\n    //   translateX(${___ * TRANSLATION_PX}px)\n    //   translateY(${___ * TRANSLATION_PX}px)\n    // `\n  });\n});"
                },
                {
                    "id": 40,
                    "hardness": 0.4,
                    "name": "Анимация с зависимостью от прокрутки страницы",
                    "description": "Необходимо накладывать на форму ввода данных анимацию появления при прокрутки к ней (когда она начинает показываться на экране). С помощью CSS-стилей форма изначально скрыта. Чтобы она появилась с анимацией, необходимо добавить на нее класс 'visible'. Элемент формы имеет id=\"form-contacts\"",
                    "default_text": "// Получаем HTML-элемент формы\nconst formHTMLElement = document.getElementById(___);\ndocument.body.addEventListener(___, () => {\n  // TODO: Получаем текущее положение элемента относительно области просмотра экрана\n  const box = ___;\n\n  // TODO: Проверяем, попадает ли форма в обозначенную область\n  if (___) {\n    // TODO: Если попадает, добавляем класс 'visible'\n    formHTMLElement.___;\n    return;\n  }\n  // TODO: Если не попадает, убираем класс 'visible'\n  formHTMLElement.___;\n});"
                },
                {
                    "id": 50,
                    "hardness": 0.2,
                    "name": "Анимация плавного раскрытия списка",
                    "description": "Необходимо создать анимацию плавного раскрытия раскрывающегося списка в тэге <details>. Для этого следует использовать анимацию максимальной высоты элемента из-за того, что реальная высота неизвестна и зависит от содержащихся внутри него элементов. Анимация плавного закрытия работать не будет, потому что тэг <details> закрывается и раскрывается моментально. Тэг имеет id=\"details\"",
                    "default_text": "// Получаем HTML-элемент раскрывающегося списка\nconst detailsElement = document.getElementById(___);\n// TODO: Добавляем на него стили для обрезки выходящего за размеры блока контента и для плавной анимации максимальной высоты\ndetailsElement.addEventListener(___, () => {\n  // TODO: Если на элементе есть определенный атрибут, отвечающий за его состояние (открыт или нет), \n  //  то элемент нужно закрыть (установить ему максимальную высоту около 20px)\n  if (___) {\n    detailsElement.___;\n    return;\n  }\n  // Иначе элемент нужно развернуть (установить ему большую максимальную высоту, которая точно всегда будет больше его реальной высоты)\n  detailsElement.___;\n});"
                },
                {
                    "id": 60,
                    "hardness": 0.2,
                    "name": "Просмотр увеличенной картинки при клике",
                    "description": "При клике на каждую картинку в галерее (то есть на каждый элемент внутри элемента с id=\"gallery\"), необходимо показывать эту картинку в увеличенном варианте, на весь экран. Возвращать исходный режим просмотра нужно по повторному клику.\n\nВ открытом для просмотра режиме необходимо добавлять элементу атрибут \"data-is-fullscreen\"",
                    "default_text": "// Получаем HTML-элемент гарелеи изображений\nconst galleryImageElements = document.querySelectorAll(___);\n___.forEach(element => {\n  element.addEventListener('click', () => {\n    // TODO: если на элементе атрибут \"data-is-fullscreen\" уже существует, его нужно убрать. Если не существует - добавить\n\n    // Если на элементе существует атрибут \"data-is-fullscreen\", необходимо добавить на элемент стили для растягивания его на весь экран поверх всех элементов\n    if (element.hasAttribute('data-is-fullscreen')) {\n      element.style.transform = 'none'; // Нужно, чтобы убрать стили от другого блока кода\n      element.style.position = 'fixed';\n      element.style.top = ;\n      element.style.left = ;\n      element.style.width = ;\n      element.style.height = ;\n      element.style.zIndex = ;\n      return;\n    }\n    // Иначе необходимо вернуть всё обратно и убрать эти стили\n    element.style.position = 'initial';\n    element.style.width = ;\n    element.style.height = ;\n  });\n});"
                },
                {
                    "id": 70,
                    "hardness": 0.1,
                    "name": "Подсчет итоговой стоимости в калькуляторе",
                    "description": "При изменении полей формы калькулятора необходимо пересчитывать итоговый результат и выводить его внутри элемента для вывода. Поле ввода цены одного телефона имеет id=\"form-calculator__input-cost\". Поле ввода количества телефоноы имеет id=\"form-calculator__input-count\". Элемент для вывода результата имеет id=\"form-calculator__result\".",
                    "default_text": "// Получаем HTML-элементы двух полей ввода и элемент для вывода результата\nconst inputCostElement = document.getElementById(___);\nconst inputCountElement = document.getElementById(___);\nconst calculatedResultElement = document.getElementById(___);\n// Функция подсчета и обновления результата\nfunction calculateAndSetResult() {\n  const result = ___;\n  ___ = String(result) || '0';\n}\n// Добавляем EventListener'ы для вызова функции обновления при вводе данных в инпуты\n___.addEventListener(___, ___);\n___.addEventListener(___, ___);"
                },
                {
                    "id": 80,
                    "hardness": 0.0,
                    "name": "Вывод данных по клику",
                    "description": "При клике на логотип сайта правой кнопкой мыши (или при долгом удержании на мобильных устройствах) необходимо показывать пользователю дату и версию сборки фронтенда.\nПусть это будет 1 апреля 2024 года, 17:15, версия Beta-1.8.1.\n\nЛоготип сайта имеет id=\"header__logo\"",
                    "default_text": "// Получаем HTML-элемент логотипа\nconst logoElement = document.getElementById(___);\n// Добавляем EventListener для показа информации\n// Самый простой способ - использовать функцию alert"
                }
            ]
        },

        {
            "id": 4,
            "year":  2002,
            "name":  "JS SPA",
            "description":  "Первый \"одностраничный\" (Single Page Application) сайт и его реализация без фреймворков на чистом JS",
            "code_language":  "javascript",
            "fragments": [
                {
                    "id": 10,
                    "hardness": 0.2,
                    "name": "Класс роутера",
                    "description": "Общая задача - создать класс Router, который будет перехватывать события перехода по внутренным ссылкам, предотвращать поведение браузера по умолчанию, и вместо этого отрисовывать страницу, подходящую под текущий url, на который пользователь перешел.\n\nНапишите описание класса Router с конструктором, принимающим два аргумента - element и routes.\n\nПервый - это рабочий элемент, внутрь которого будут монтироваться страницы. В нашем случае это элемент с id=\"main\".\n\nВторой аргумент - это объект, определяющий, по каким ссылкам какиме страницы нужно показывать и прочие их параметры.\n\nНе забудьте прописать Router в глобальную область видимости, чтобы им можно было пользоваться из других блоков кода.",
                    "default_text": "// Определяем класс роутера\nclass Router {\n  // Перечислим для удобства все поля этого класса\n  rootElement;\n  routes;\n\n  constructor(element, routes) {\n    // Если element не передан или это не объект класса HTMLElement, показываем ошибку и выходим\n    if (___) {\n      console.error(___);\n      return;\n    }\n    // TODO: Сохраняем рабочий элемент и роуты в поля класса\n    ___;\n    // Запускаем метод установки хэндлеров на события перехода по страницам.\n    // Этот метод реализовывает кто-то другой в другом фрагменте\n    this.setHrefEventCatchers();\n    // Запускаем метод перехвата браузерных кнопок назад/вперед\n    // Этот метод реализовывает кто-то другой в другом фрагменте\n    this.setPopstateHandler();\n  }\n}\n// TODO: Добавить Router как глобавльную константу, прописав его как свойство window"
                },
                {
                    "id": 20,
                    "hardness": 1,
                    "name": "Перехват переходов по ссылкам",
                    "description": "Необходимо добавить классу Router метод setHrefEventCatchers, не принимающий никаких аргументов, при вызове устанавливающий перехват событий переходов по ссылкам, и вызывающий метод Router.goto, в который передается ссылка на страницу, на которую нужно перейти.\nПереход необходимо перехватывать только по внутренним ссылкам.",
                    "default_text": "Router.prototype.setHrefEventCatchers = function() {\n  // Добавляем EventListener на <body>, в котором обрабатываем клики на ссылки\n  ___.addEventListener(___, (event) => {\n    const clickedEl = event.target;\n    // Ничего не делаем, если кликнут не элемент с тэгом <a>, и его атрибут href не является внутренней ссылкой (начинается с http:// или https://,\n    // с tel:, mailto:, и др.), или является якорной ссылкой (начинается не с #). Это удобно проверить с помощью регулярного выражения\n    if (___) {\n      return;\n    }\n    // Логируем событие перехвата перехода по ссылке, отменяем браузерный обычный переход по ссылке\n    ___;\n\n    // Вызываем метод перехода на страницу.\n    // Этот метод реализовывает кто-то другой в другом фрагменте\n    this.goto(hrefAttr);\n  });\n};"
                },
                {
                    "id": 30,
                    "hardness": 0.6,
                    "name": "Переход по заданной ссылке",
                    "description": "Необходимо добавить классу Router метод goto, который находит в объекте Router.routes подходящую под переданную в него, как аргумент, текстовую ссылку. В случае, есть подходящий роут находится, необходимо вызвать метод Router.render, передав в него найденный объект роута из Router.routes. Также необходимо вызвать метод Router.pushPathToHistory, передав в него саму текстовую ссылку.",
                    "default_text": "Router.prototype.goto = function(path) {\n  // TODO: Выполняем поиск по ключам роутов из this.routes. Если подходящий не найден, логируем ошибку и выходим\n  ___;\n  if (___) {\n    console.error(___)\n    return;\n  }\n  // Если подходящий роут найден, запускаем метод render, в который передаем объект найденного роута\n  // Этот метод реализовывает кто-то другой в другом фрагменте\n  this.render(___);\n  // Добавляем ссылку в историю браузера (сама он не добавится, ведь переход браузера по ссылке мы перехватили)\n  // Этот метод реализовывает кто-то другой в другом фрагменте\n  this.pushPathToHistory(path);\n};"
                },
                {
                    "id": 40,
                    "hardness": 0.8,
                    "name": "Рендеринг страницы",
                    "description": "Необходимо добавить классу Router метод render. Он принимает как аргумент объект route, полями которого описывается необходимая для отрисовки страница.\nМетод должен изменять заголовок текущей вкладки браузера на route.title, отрисовывать в рабочем элементе (Рабочий элемент роутера хранится в Router.rootElement. Он точно является объектом класса HTMLElement) HTML-разметку из поля route.html, и после того, как новая разметка точно разобрана браузером и элементы появились в DOM, вызывать метод route.unmount() страницы, показываемой до этого, и метод route.mount() страницы, которую необходимо показать.\n\nСледует пользоваться методом Router.nextTick(), возвращающим Promise, разрешающимся после разбора браузером html-разметки и появления всех элементов в DOM.",
                    "default_text": "Router.prototype.render = async function(route) {\n  // TODO: Изменяем заголовок страницы документа на route.title\n  ___;\n  // Вызываем метод анимации перехода по страницам и ожидаем разрешения на отрисовку новой страницы\n  // Этот метод реализовывает кто-то другой в другом фрагменте\n  await this.animateElementShowHide();\n  // TODO: Заменяем всю разметку внутри рабочего элемента на route.html\n  ___;\n  // Ждем разбора и отрисовки браузером вставленного html (когда элементы появятся в DOM)\n  // Этот метод реализовывает кто-то другой в другом фрагменте\n  await this.nextTick();\n  // TODO: Вызываем функцию unmount прыдыдущей страницы, вызываем функцию route.mount новой страницы\n  ___;\n};"
                },
                {
                    "id": 50,
                    "hardness": 0.9,
                    "name": "Анимация плавного перехода по страницам",
                    "description": "Необходимо добавить классу Router метод animateElementShowHide. Он не принимает никаких аргументов.\nОн должен плавно скрывать весь контент внутри рабочего элемента (Рабочий элемент роутера хранится в Router.rootElement. Он точно является объектом класса HTMLElement), после чего разрешать Promise, который и является возвращаемым значением этой функции. После этого необходимо плавно показать весь контент внутри рабочего элемента.\n\nЧто происходит во внешнем коде и как это работает? При перерисовке страницы вызывается наш метод Router.animateElementShowHide. Пока промис, который возвращается из этого метода не будет разрешен, HTML-код новой страницы не будет вставлен в рабочий элемент. Таким образом, после того, как мы плавно скрываем страницу и разрешаем промис, тем самым, мы даем разрешение на обновление HTML-разметки, которая сразу обновляется. Потому мы сразу можем начинать плавную анимацию показа содержимого рабочего элемента, и быть уверенными в том, что в нем появилась новая страница.",
                    "default_text": "Router.prototype.animateElementShowHide = function() {\n  // Создаем промис, который будет возвращен из фукции, и сохраняем его функцию resolve, чтобы он мог разрешится,\n  // когда разрешено будет вставить в рабочий элемент html-разметку новой страницы\n  let resolvePromiseFunction; // Сюда можно сохранить функцию resolve\n  const promise = new Promise(___);\n  // TODO: Добавляем рабочему элементу стили для плавного скрытия содержимого\n  ___;\n  // TODO: Через *выберите сколько* миллисекунд резолвим промис (из-за этого сразу во внешнем коде вставится html-разметка новой страницы) и плавно показываем содержимое новой страницы\n  ___;\n  return promise;\n};"
                },
                {
                    "id": 60,
                    "hardness": 0.2,
                    "name": "Промис ожидания отрисовки элементов",
                    "description": "Необходимо добавить классу Router метод nextTick. Он не принимает никаких аргументов.\nМетод должен возвращать Promise, разрешающийся после разбора браузером html-разметки и появления всех элементов в DOM.\n\nДля этого можно использовать минимум 3 разных подхода. Как только в голову придет хотя бы какой-то метод, смело обращайся, давай обсудим его.",
                    "default_text": "Router.prototype.nextTick = function() {\n  // Создаем промис, который будет возвращен из фукции, и сохраняем его функцию resolve, чтобы выполнить её позже\n  let resolvePromiseFunction; // Сюда можно сохранить функцию resolve\n  const promise = new Promise(___);\n  // TODO: Ожидаем появления элементов на странице и после этого вызываем функцию разрешения промиса\n  ___;\n  return promise;\n};"
                },
                {
                    "id": 70,
                    "hardness": 0.0,
                    "name": "Добавление страницы в историю браузера",
                    "description": "Необходимо добавить классу Router метод pushPathToHistory. Он принимает как аргумент текстовую ссылку, которую необходимо добавить в историю.\nМетод необходим для того, чтобы при нажатии браузерных кнопок назад/вперед, браузер бы возвращался к предыдущим/следующим страницам, ведь из-за того, что классический переход браузера по ссылкам мы перехватываем, они не добавляются в историю просто так.",
                    "default_text": "Router.prototype.pushPathToHistory = function(path) {\n  // TODO: Добавляем ссылку в браузерную историю\n};"
                },
                {
                    "id": 80,
                    "hardness": 0.1,
                    "name": "Перехват браузерных кнопок назад/вперед",
                    "description": "Необходимо добавить классу Router метод setPopstateHandler. Он не принимает никаких аргументов.\nМетод должен добавлять прослушивание события перехода по браузерной истории, и при срабатывании этого события вызывать метод Router.goto, передав текст, являющийся частью \"path\" от полного URL в адресной строке.\n(При нажатии браузерных кнопок вперед/назад и иных переходах по истории, ссылка в ардесной строке подменяется сразу браузером. Потому именно оттуда мы можем узнать, куда необходимо переходить с помощью метода Router.goto)",
                    "default_text": "Router.prototype.setPopstateHandler = function() {\n  // Добавляем прослушивание события перехода по браузерной истории.\n  ___.addEventListener(___, () => {\n    // При срабатывании события вызываем метод goto передав в него текст, являющийся частью \"path\" от полного URL в адресной строке\n    // Этот метод реализовывает кто-то другой в другом фрагменте\n    this.goto(___);\n  });\n};"
                },
                {
                    "id": 90,
                    "hardness": 0.7,
                    "name": "Создание роутера и описание страниц",
                    "description": "Необходимо создать объект класса Router. Его конструктор принимает два аргумента element и routes.\nПервый - это рабочий элемент, внутрь которого будут монтироваться страницы. В нашем случае это элемент с id=\"main\".\nВторой аргумент - это объект, определяющий, по каким ссылкам какиме страницы нужно показывать и прочие их параметры. Структура этого объекта указана в комментариях в коде. Для каждой страницы все поля title, html, mount, unmout являются обязательными. Ключ каждого объекта внутри routes интерпритируется как регулярное выражение для проверки значения атрибутов href из элементов ссылок, по которым осуществляются переходы. Одним словом, если \"path\" подходит под указанный ключ роута в объекте routes, рендерится этот роут",
                    "default_text": "// TODO: Создать объект роутера.\n// Структура объекта routes (второго параметра конструктора класса Router):\n// {\n//   '/some-path': {\n//      title: 'Название страницы',\n//      html: '<h1>HTML-код страницы</h1>',\n//      mount() {},\n//      unmount() {},\n//   },\n//   ...\n// };"
                }
            ]
        }
    ]
}
